"""Geometric attitude controller."""
import numpy as np
import pybullet as p
from scipy.spatial.transform import Rotation

from mav_sim.config import cfg


class LeeGeometricController:
    """ 
        Implements the Attitude Control part of the work
        Lee, Taeyoung, Melvin Leok, and N. Harris McClamroch. 
        "Geometric tracking control of a quadrotor UAV on SE (3)." 
        49th IEEE conference on decision and control (CDC). IEEE, 2010.
    """

    def compute_torque(self, W_R_B, W_R_B_ref, B_omega, B_omega_ref, B_omega_dot_ref):
        """"
        Attitude control loop
        In: 
            W_R_B:          current attitude (3x3 rot matrix) as np.array of shape (3,3)
            W_R_B_ref:      desired attitude (3x3 rot matrix) as np.array of shape (3,3)
            B_omega:        current ang. vel. in body as np.array of shape (3,)
            B_omega_ref:    des ang vel. vel. in body as np.array of shape (3,)
            B_omega_dot_ref: des. ang. acc. in body as np.array of shape (3,)
        Out: 
            Torque expressed in body frame to be generated by the actuators.
            np.array of shape (3,)
        """
        J = np.diag(np.array(cfg.ctr.inertia))

        if cfg.ctr.open_loop:
            return J.dot(B_omega_dot_ref)

        R = W_R_B           # Current attitude - as rotation matrix
        Rd = W_R_B_ref      # Desired attitude - as rotation matrix

        # Compute torque given thrust and attitude
        e_r = 0.5*self.vee_map(Rd.T.dot(R) - R.T.dot(Rd))
        e_w = B_omega - R.T.dot(Rd).dot(B_omega_ref)
        e_f = np.cross(B_omega, J.dot(B_omega)) \
            - J.dot(self.hat_map(B_omega).dot(R.T).dot(Rd).dot(B_omega_ref)) \
            + J.dot(R.T).dot(Rd).dot(B_omega_dot_ref)

        # Total torque
        B_torque_cmd = - np.diag(cfg.ctr.attitude_gains)@(e_r) \
                       - np.diag(cfg.ctr.angular_rate_gains)@(e_w) \
                       + e_f

        return B_torque_cmd

    def vee_map(self, skew):
        """
            Return the vee map of a vector
            from skew to vector
        """
        vec = np.array([skew[2, 1], skew[0, 2], skew[1, 0]])
        return vec

    def hat_map(self, vec):
        """
            Return that hat map of a vector
            from vector to skew
            Inputs: 
                vec - 3 element vector
            Outputs:
                skew - 3,3 skew symmetric matrix
        """
        vec = np.squeeze(vec)
        skew = np.array([
                        [0, -vec[2], vec[1]],
                        [vec[2], 0, -vec[0]],
                        [-vec[1], vec[0], 0]])
        return skew

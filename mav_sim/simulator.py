"""Main simulation interface. Steps the attitude control loop and dynamics."""
import os
import numpy as np

from mav_sim.config import cfg
from mav_sim.control import LeeGeometricController
from mav_sim.allocation import MotorAllocation
from mav_sim.powertrain import PowertrainModel
from mav_sim.dynamics import MavDynamics


class MavSim(MavDynamics):
    """
    MavSim simulator. Load dynamics, actuaiton models and attitude controller. 
    """

    def __init__(self, mavsim_params, seed=0):
        params_path_file = os.path.join(os.path.dirname(
            os.path.abspath(__file__)), "params", mavsim_params)
        cfg.merge_from_file(params_path_file)
        super(MavSim, self).__init__(seed=seed)

        # Set step frequency for position (simulation) and attitude controller
        assert int(cfg.sim.attitude_control_step_freq /
                   cfg.sim.pos_control_step_freq) >= 1

        # Initialize attitude controller.
        self.attitude_controller = LeeGeometricController()

        # Initialize Mixer/Motor allocation strategy
        self.motor_allocation = MotorAllocation()

        # Initialize powertrain model
        self.powertrain = PowertrainModel()

        self.check_position_control_freq(cfg.sim.pos_control_step_freq)
        print("[MavSim] Loaded Params: ")
        print(cfg)

    def step_attitude_control_and_dynamics(self, B_thrust, W_R_B_ref, B_omega_ref, B_omega_dot_ref=np.zeros(3)):
        """
            Simulates an attitude controller MAV.
            Input: commands generated by a cascaded (e.g., RTMPC) position controller
                - B_thrust: np.array(3), desired thrust force in B frame 
                - B_rpy_ref: np.array(3), desired attitude in B: B_rpy_ref; Z-Y-X intrisic euler angles
                - B_omega_ref: np.array(3), desired angular velocity in B frame
                - B_omega_dot_ref: np.array(3), desired angular acceleration in B frame

            Output: the state of the MAV
        """
        assert W_R_B_ref.shape == (3, 3)
        assert B_omega_ref.shape == (3,)
        assert B_thrust.shape == (3,)
        assert B_omega_dot_ref.shape == (3,)

        for _ in range(int(cfg.sim.attitude_control_step_freq/cfg.sim.pos_control_step_freq)):
            # Get state estimate
            s = self.get_state()

            # Step attitude controller
            B_torque = self.attitude_controller.compute_torque(
                s["W_rot_B"], W_R_B_ref, s["B_omega"], B_omega_ref, B_omega_dot_ref)

            # Step motor allocation matrix
            desired_motor_forces = self.motor_allocation.compute_desired_motor_forces(
                B_thrust_f=B_thrust, B_torque=B_torque)

            # Powertrain model: convert desired force into actual force/torque (force->pwm->thrust,torque)
            motor_forces, motor_torques = self.powertrain.compute_motor_forces_torques(
                desired_motor_forces)
                
            self.step_dynamics(B_motor_forces_z=motor_forces,
                               B_motor_torques_z=motor_torques)

        return self._get_obs_from_curr_state()

    def reset(self):
        self.reset_dynamics()

        self.powertrain.reset()  # state of delay block
        # Generate observation
        return self._get_obs_from_curr_state()

    def check_position_control_freq(self, pos_control_freq_hz):
        """
            Defines the duration of one step
            pos_control_freq_hz: frequency (Hz) that defines the step duration. 
        """
        assert pos_control_freq_hz <= cfg.sim.physics_freq, f"Step freq" \
            "({pos_control_freq_hz} [Hz]) should be smaller than physics freq ({cfg.sim.physics_freq} [Hz])."
        assert pos_control_freq_hz <= cfg.sim.attitude_control_step_freq, f"Step freq" \
            "({pos_control_freq_hz} [Hz]) should be smaller than attitude control freq ({cfg.sim.attitude_control_step_freq} [Hz])."
        assert cfg.sim.physics_freq % pos_control_freq_hz == 0, f"Step freq" \
            "({pos_control_freq_hz} [Hz]) should be integer multiple of phyisics freq ({cfg.sim.physics_freq} [Hz])."
        assert cfg.sim.attitude_control_step_freq % pos_control_freq_hz == 0, f"Step freq" \
            "({pos_control_freq_hz} [Hz]) should be integer multiple of attitude control freq ({cfg.sim.attitude_control_step_freq} [Hz])."

    def reset_to_state(self, W_pos=np.zeros(3), B_rpy=np.zeros(3), W_vel=np.zeros(3)):
        self.reset_to_init_state(W_pos=W_pos, B_rpy=B_rpy, W_vel=W_vel)
        return self._get_obs_from_curr_state()

    def _get_obs_from_curr_state(self):
        """
        This is a conveninent representation of the state, 
        that can be used e.g. as a gym observation. 
        It contains position, velocity and roll/pitch in a gravity aligned, 
        yaw-fixed frame. You can build your own by simply using 
        """
        s = self.get_state()
        yaw = s["B_rpy"][2]
        B_R_yaw_I = np.array(
            [[np.cos(yaw), np.sin(yaw)], [-np.sin(yaw), np.cos(yaw)]])  # TODO: remove
        I_rp = np.matmul(B_R_yaw_I.T, s["B_rpy"][0:2])
        # Wondering if this procedure is wrong?
        obs = np.hstack([s["W_pos"], s["W_vel"], I_rp])
        return obs
